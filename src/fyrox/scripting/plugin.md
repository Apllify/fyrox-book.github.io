# Plugins

A game based on Fyrox is a plugin to the engine and the editor. Plugin defines global application logic and can provide
a set of scripts, that can be used to assign custom logic to scene nodes. Every script can be attached to only one
plugin.

Plugin is an "entry point" of your game, it has a fixed set of methods that can be used for initialization, update,
OS event handling, etc. Every plugin is statically linked to the engine (editor), there is no support for hot-reloading
due to lack of stable ABI in Rust.

The main purpose of the plugins is to hold and operate on some global application data, that can be used in scripts; 
provide set of scripts to the engine.

## Structure

Plugin structure is defined by [Plugin](https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html) trait. Typical
implementation can be generated by `fyrox-template` tool, and it looks something like this:

```rust
# extern crate fyrox;
use fyrox::{
    core::{
        pool::Handle,
        uuid::{uuid, Uuid},
    },
    event::Event,
    plugin::{Plugin, PluginContext, PluginRegistrationContext},
    scene::{Scene, node::TypeUuidProvider},
};

pub struct Game {
    scene: Handle<Scene>,
}

impl TypeUuidProvider for Game {
    // Returns unique plugin id for serialization needs.
    fn type_uuid() -> Uuid {
        // Ideally this should be unique per-project.
        uuid!("cb358b1c-fc23-4c44-9e59-0a9671324196")
    }
}

impl Game {
    pub fn new() -> Self {
        Self {
            scene: Default::default(),
        }
    }

    fn set_scene(&mut self, scene: Handle<Scene>, _context: PluginContext) {
        self.scene = scene;

        // Do additional actions with scene here.
    }
}

impl Plugin for Game {
    fn on_register(&mut self, _context: PluginRegistrationContext) {
        // Register your scripts here.
    }

    fn on_standalone_init(&mut self, context: PluginContext) {
        self.set_scene(context.scenes.add(Scene::new()), context);
    }

    fn on_enter_play_mode(&mut self, scene: Handle<Scene>, context: PluginContext) {
        // Obtain scene from the editor.
        self.set_scene(scene, context);
    }

    fn on_leave_play_mode(&mut self, context: PluginContext) {
        self.set_scene(Handle::NONE, context)
    }

    fn update(&mut self, _context: &mut PluginContext) {
        // Add your global update code here.
    }

    fn id(&self) -> Uuid {
        Self::type_uuid()
    }

    fn on_os_event(&mut self, _event: &Event<()>, _context: PluginContext) {
        // Do something on OS event here.
    }

    fn on_unload(&mut self, _context: &mut PluginContext) {
        // Do a cleanup here.
    }
}
```

## Execution Flow

Execution flow of the plugin code is quite complex and depends on the mode - either standalone or editor, here's 
overall execution flow diagram:

![Execution Flow](./plugin_flow.svg)

[Plugin](https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html) trait methods highlighted blue, conditions - green,
entry point (`Start`) - yellow, application shutdown (`End`) - red.

Execution starts from `on_register` method, its purpose is to provide information about scripts and custom scene nodes
by registering respective entities in `PluginRegistrationContext`. Every script or custom scene node **must** be 
registered before you can use it, otherwise the engine will not know that the script or node exists.

Next step is different depending on where you game is running: as a standalone version or in the editor. Standalone 
version is used for production builds to get final executable without editor. 

For standalone version initialization happens in `on_standalone_init` method. When you run your game in the editor,
the initialization happens in `on_enter_play_mode`. Why there are two different methods for initialization, can't we
use a single method? No, we can't, it is because when the game is running in the editor you run your game somewhat 
"partially" - it means that you can load a scene in the editor and click "Play", the editor will call `on_enter_play_mode`
which will supply you with a copy of your currently loaded scene. When you run production build, `on_standalone_init`
allows you to perform full initialization, load a bunch of required scenes at once (i.e. one for main menu, one for
game level).

Next step is `on_update`, it is called at fixed rate of 60 Hz. It will be called until you either leave play mode in
the editor, or close your game application in production build.

When you leave play mode in the editor, `on_leave_play_mode` will be called and plugin execution will pause until you
enter game mode again. When you close your game application in production build, `on_unload` will be called, thus
allowing you to do a required cleanup.

## Plugin Context

Vast majority of methods accept `PluginContext` - it provides almost full access to engine entities, it has access
to the renderer, scenes container and resource manager.

**Caveat:** Use scenes container very carefully, do not delete all scenes from it, because it also contains some editor
specific scenes when your game run in editor mode.

## Plugin Limitations

Plugin does **not** have access to user interface instance of the engine, you must create your own instance and back
it with separate render pass to draw the UI. Next chapters will cover this aspect.

Plugin does not have access to the application window and global access to the engine, to obtain access to those entities
you must use `Executor` instance in production builds or `Editor` instance in developer builds.

Next chapters will cover these aspects.